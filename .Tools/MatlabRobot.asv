% ️ Load the robot model
robot = loadrobot('kukaIiwa14', 'DataFormat', 'row', 'Gravity', [0 0 -9.81]);

%  Create Inverse Kinematics object
ik = inverseKinematics('RigidBodyTree', robot);

% Define multiple end-effector poses for iteration analysis
positions = [0.0, 0.0, 3.0;    % 
             0.3, 0.3, 0.7;    % 
             0.5, 0.1, 0.3;    % 
             0.6, 0.0, 0.2];   % 

% Define multiple end-effector angles for iteration analysis
angles = [0, 1, 0 pi/2;
          0, 0, 1, pi;
          0, 0, 1, pi;
          0, 0, 1, pi;
    
            ]

% Preallocate for iteration count and computation time
iterationCounts = zeros(size(positions, 1), 1);
computationTimes = zeros(size(positions, 1), 1);

% Initial guess for joint angles
initialGuess = robot.homeConfiguration;

% Loop through each pose
for i = 1:size(positions, 1)
    % Create end-effector pose (translation + fixed orientation)
    endEffectorPose = trvec2tform(positions(i, :)) * axang2tform([0 1 0 -pi/2]);

    % Solve Inverse Kinematics
    tic;
    [configSol, solInfo] = ik('iiwa_link_ee', endEffectorPose, ones(1,6), initialGuess);
    computationTimes(i) = toc;

    % Store Iterations
    iterationCounts(i) = solInfo.Iterations;

    % Display iteration count
    fprintf('Pose %d: Iterations = %d, Time = %.4f sec\n', i, solInfo.Iterations, computationTimes(i));

    % Plot Robot Configuration
    figure;
    show(robot, configSol, 'Frames', 'off', 'PreservePlot', false);
    title(['Configuration for Pose ', num2str(i)]);
    view(3);
    axis auto;
    grid on;
end

%  Plot Iteration Count
figure;
bar(iterationCounts);
xlabel('Pose Number');
ylabel('Number of Iterations');
title('Iterations Required for Different End-Effector Poses');
grid on;

% ️⃣ Plot Computation Time
figure;
bar(computationTimes);
xlabel('Pose Number');
ylabel('Computation Time (s)');
title('Computation Time for Inverse Kinematics');
grid on;